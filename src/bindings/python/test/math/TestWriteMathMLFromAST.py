#
# @file    TestWriteMathMLFromAST.py
# @brief   Write MathML unit tests starting from ASTNodes
#
# @author  Akiya Jouraku (Python conversion)
# @author  Sarah Keating 
# 
# ====== WARNING ===== WARNING ===== WARNING ===== WARNING ===== WARNING ======
#
# DO NOT EDIT THIS FILE.
#
# This file was generated automatically by converting the file located at
# src/sbml/test/TestWriteMathMLFromAST.cpp
# using the conversion program dev/utilities/translateTests/translateTests.pl.
# Any changes made here will be lost the next time the file is regenerated.
#
# -----------------------------------------------------------------------------
# This file is part of libSBML.  Please visit http://sbml.org for more
# information about SBML, and the latest version of libSBML.
#
# Copyright 2005-2010 California Institute of Technology.
# Copyright 2002-2005 California Institute of Technology and
#                     Japan Science and Technology Corporation.
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation.  A copy of the license agreement is provided
# in the file named "LICENSE.txt" included with this software distribution
# and also available online as http://sbml.org/software/libsbml/license.html
# -----------------------------------------------------------------------------

import sys
import unittest
import libsbml

def MATHML_FOOTER():
  return "</math>"
  pass

def MATHML_HEADER():
  return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n"
  pass

def MATHML_HEADER_UNITS():
  return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\""
  pass

def MATHML_HEADER_UNITS2():
  return " xmlns:sbml=\"http://www.sbml.org/sbml/level3/version2/core\">\n"
  pass

def XML_HEADER():
  return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  pass

def wrapMathML(s):
  r = XML_HEADER()
  r += MATHML_HEADER()
  r += s
  r += MATHML_FOOTER()
  return r
  pass

def wrapMathMLUnits(s):
  r = XML_HEADER()
  r += MATHML_HEADER_UNITS()
  r += MATHML_HEADER_UNITS2()
  r += s
  r += MATHML_FOOTER()
  return r
  pass


class TestWriteMathMLFromAST(unittest.TestCase):

  global S
  S = None
  global N
  N = None

  def setUp(self):
    self.N = None
    self.S = None
    pass  

  def tearDown(self):
    self.N = None
    self.S = None
    pass  

  def test_MathMLFromAST_ci(self):
    expected = wrapMathML("  <ci> foo </ci>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME)
    self.N.setName("foo")
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_ci_class(self):
    expected = wrapMathML("  <ci class=\"test\"> foo </ci>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME)
    self.N.setName("foo")
    self.assertTrue( self.N.setClass("test") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_ci_definitionURL(self):
    expected = wrapMathML("  <ci definitionURL=\"http://someurl\"> foo </ci>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME)
    self.N.setName("foo")
    xml = libsbml.XMLAttributes()
    xml.add("", "http://someurl")
    self.N.setDefinitionURL(xml)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_ci_id(self):
    expected = wrapMathML("  <ci id=\"test\"> foo </ci>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME)
    self.N.setName("foo")
    self.assertTrue( self.N.setId("test") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_ci_style(self):
    expected = wrapMathML("  <ci style=\"test\"> foo </ci>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME)
    self.N.setName("foo")
    self.assertTrue( self.N.setStyle("test") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_1(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> 0 <sep/> 3 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(0.0,3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_2(self):
    expected = wrapMathML("  <cn> 2000 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(2e3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_3(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> 1234567.8 <sep/> 3 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(1234567.8,3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_4(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> 6.0221367 <sep/> 23 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(6.0221367,23)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_5(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> 4 <sep/> -6 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(0.000004)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_6(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> 4 <sep/> -12 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(0.000004,-6)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_e_notation_7(self):
    expected = wrapMathML("  <cn type=\"e-notation\"> -1 <sep/> -6 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL_E)
    self.N.setValue(-1.0,-6)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_integer(self):
    expected = wrapMathML("  <cn type=\"integer\"> 5 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_INTEGER)
    self.N.setValue((long)(5))
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_rational(self):
    expected = wrapMathML("  <cn type=\"rational\"> 1 <sep/> 3 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_RATIONAL)
    self.N.setValue(long,3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_real_1(self):
    expected = wrapMathML("  <cn> 1.2 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(1.2)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_real_2(self):
    expected = wrapMathML("  <cn> 1234567.8 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(1234567.8)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_real_3(self):
    expected = wrapMathML("  <cn> -3.14 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(-3.14)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_real_locale(self):
    expected = wrapMathML("  <cn> 2.72 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(2.72)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_cn_units(self):
    expected = wrapMathMLUnits("  <cn sbml:units=\"mole\"> 1.2 </cn>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(1.2)
    self.N.setUnits("mole")
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_exponentiale(self):
    expected = wrapMathML("  <exponentiale/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_CONSTANT_E)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_false(self):
    expected = wrapMathML("  <false/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_CONSTANT_FALSE)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_infinity(self):
    expected = wrapMathML("  <infinity/>\n")
    self.N = libsbml.ASTNode()
    self.N.setValue( util_PosInf() )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_infinity_neg(self):
    expected = wrapMathML("  <apply> <minus/> <infinity/> </apply>\n"  
    )
    self.N = libsbml.ASTNode()
    self.N.setValue(- util_PosInf())
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_infinity_neg1(self):
    expected = wrapMathML("  <apply> <minus/> <infinity/> </apply>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue(- util_PosInf())
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_notanumber(self):
    expected = wrapMathML("  <notanumber/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_REAL)
    self.N.setValue( util_NaN() )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_pi(self):
    expected = wrapMathML("  <pi/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_CONSTANT_PI)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_constant_true(self):
    expected = wrapMathML("  <true/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_CONSTANT_TRUE)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_csymbol_avogadro(self):
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/avogadro\"> NA </csymbol>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME_AVOGADRO)
    self.N.setName("NA")
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_csymbol_delay(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/delay\"> my_delay </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 0.1 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_DELAY)
    self.assertTrue( self.N.setName("my_delay") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c1.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_REAL)
    self.assertTrue( c2.setValue(0.1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_csymbol_rateof(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/rateOf\"> my_delay </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_RATE_OF)
    self.assertTrue( self.N.setName("my_delay") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c1.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_csymbol_time(self):
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/time\"> t </csymbol>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME_TIME)
    self.N.setName("t")
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_csymbol_time_no_name(self):
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/time\"/>\n")
    self.N = libsbml.ASTNode(libsbml.AST_NAME_TIME)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_func_style(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <sin style=\"a\"/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_SIN)
    self.N.setStyle("a")
    c = libsbml.ASTNode(libsbml.AST_INTEGER)
    c.setValue((int)(1))
    self.N.addChild(c)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_function_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <ci> foo </ci>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION)
    self.assertTrue( self.N.setName("foo") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c3) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_function_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <ci> foo </ci>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <apply>\n" + 
    "      <ci> bar </ci>\n" + 
    "      <ci> z </ci>\n" + 
    "    </apply>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION)
    self.assertTrue( self.N.setName("foo") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    bar = libsbml.ASTNode(libsbml.AST_FUNCTION)
    bar.setName("bar")
    cz = libsbml.ASTNode(libsbml.AST_NAME)
    cz.setName("z")
    self.assertTrue( bar.addChild(cz) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(bar) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_generic_csymbol(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/some/unknown/URL\"> unknown_function </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 0.1 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_CSYMBOL_FUNCTION)
    self.assertTrue( self.N.setName("unknown_function") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.setDefinitionURL("http://www.sbml.org/sbml/symbols/some/unknown/URL") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c1.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_REAL)
    self.assertTrue( c2.setValue(0.1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_implies(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <implies/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_LOGICAL_IMPLIES)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c3) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_lambda(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    self.N = libsbml.ASTNode(libsbml.AST_LAMBDA)
    c1_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1_1.setName("x")
    c2_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c2_1.setName("y")
    c3 = libsbml.ASTNode(libsbml.AST_PLUS)
    c3_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c3_1.setName("x")
    c3_2 = libsbml.ASTNode(libsbml.AST_NAME)
    c3_2.setName("y")
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    self.N.addChild(c1_1)
    self.N.addChild(c2_1)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_lambda1(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    self.N = libsbml.ASTNode(libsbml.AST_LAMBDA)
    c1_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1_1.setName("x")
    c2_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c2_1.setName("y")
    c3 = libsbml.ASTNode(libsbml.AST_PLUS)
    c3_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c3_1.setName("x")
    c3_2 = libsbml.ASTNode(libsbml.AST_NAME)
    c3_2.setName("y")
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    self.N.addChild(c1_1)
    self.N.addChild(c2_1)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_lambda_no_bvars(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    self.N = libsbml.ASTNode(libsbml.AST_LAMBDA)
    c3 = libsbml.ASTNode(libsbml.AST_PLUS)
    c3_1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3_1.setValue(2)
    c3_2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3_2.setValue(2)
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_log(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_LOG)
    c1_1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    self.assertTrue( c1_1.setValue(2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1_1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("N") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_log_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <ci> x </ci>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_LOG)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c1.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("N") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_log_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_LOG)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("N") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_log_4(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 10 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_LOG)
    c1_1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    self.assertTrue( c1_1.setValue(10) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1_1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("N") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c3.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c3) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_max(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <max/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_MAX)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_min(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <min/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_MIN)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_minus(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <minus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_MINUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_minus_unary_1(self):
    expected = wrapMathML("  <cn type=\"integer\"> -2 </cn>\n"  
    )
    self.N = libsbml.ASTNode(libsbml.AST_INTEGER)
    self.N.setValue(-2)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_minus_unary_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <minus/>\n" + 
    "    <ci> a </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_MINUS)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("a")
    self.N.addChild(c1)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_nested_funcs(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <divide/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <apply>\n" + 
    "      <sin/>\n" + 
    "      <cn type=\"rational\"> 3 <sep/> 5 </cn>\n" + 
    "    </apply>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_DIVIDE)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_RATIONAL)
    c2.setValue(long,long)
    sin = libsbml.ASTNode(libsbml.AST_FUNCTION_SIN)
    sin.addChild(c2)
    self.N.addChild(c1)
    self.N.addChild(sin)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_piecewise1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n"  + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_PIECEWISE)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(0)
    c2 = libsbml.ASTNode(libsbml.AST_RELATIONAL_LT)
    c2_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c2_1.setName("x")
    c2_2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2_2.setValue(0)
    c2.addChild(c2_1)
    c2.addChild(c2_2)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(0)
    c4 = libsbml.ASTNode(libsbml.AST_RELATIONAL_EQ)
    c4_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c4_1.setName("x")
    c4_4 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c4_4.setValue(0)
    c4.addChild(c4_1)
    c4.addChild(c4_4)
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.N.addChild(c3)
    self.N.addChild(c4)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_piecewise_no_piece1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n"  + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_PIECEWISE)
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    c3.setName("x")
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_piecewise_otherwise1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n"  + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_PIECEWISE)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(0)
    c2 = libsbml.ASTNode(libsbml.AST_RELATIONAL_LT)
    c2_1 = libsbml.ASTNode(libsbml.AST_NAME)
    c2_1.setName("x")
    c2_2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2_2.setValue(0)
    c2.addChild(c2_1)
    c2.addChild(c2_2)
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    c3.setName("x")
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_binary(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_nary_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_nary_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    plus = libsbml.ASTNode(libsbml.AST_PLUS)
    plus.addChild(c1)
    plus.addChild(c2)
    self.N.addChild(plus)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_nary_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    plus = libsbml.ASTNode(libsbml.AST_PLUS)
    plus.addChild(c2)
    plus.addChild(c3)
    self.N.addChild(c1)
    self.N.addChild(plus)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_nary_4(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <apply>\n" + 
    "      <times/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "      <ci> z </ci>\n" + 
    "    </apply>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(long)
    cx = libsbml.ASTNode(libsbml.AST_NAME)
    cx.setName("x")
    cy = libsbml.ASTNode(libsbml.AST_NAME)
    cy.setName("y")
    cz = libsbml.ASTNode(libsbml.AST_NAME)
    cz.setName("z")
    times = libsbml.ASTNode(libsbml.AST_TIMES)
    times.addChild(cx)
    times.addChild(cy)
    times.addChild(cz)
    self.N.addChild(c1)
    self.N.addChild(c2)
    self.N.addChild(times)
    self.N.addChild(c3)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_plus_nary_5(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 4 </cn>\n" + 
    "    <cn type=\"integer\"> 5 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_PLUS)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(1)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(2)
    c3 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c3.setValue(3)
    c4 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c4.setValue(4)
    c5 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c5.setValue(5)
    plus = libsbml.ASTNode(libsbml.AST_PLUS)
    plus.addChild(c4)
    plus.addChild(c5)
    plus1 = libsbml.ASTNode(libsbml.AST_PLUS)
    plus1.addChild(plus)
    plus1.addChild(c3)
    plus2 = libsbml.ASTNode(libsbml.AST_PLUS)
    plus2.addChild(plus1)
    plus2.addChild(c2)
    self.N.addChild(c1)
    self.N.addChild(plus2)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_quotient(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <quotient/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_QUOTIENT)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_rem(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <rem/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_REM)
    c1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c1.setValue(long)
    c2 = libsbml.ASTNode(libsbml.AST_INTEGER)
    c2.setValue(long)
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_replaceIDWithFunction_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <power/>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <cn> 1 </cn>\n" + 
    "    </apply>\n" + 
    "    <cn> 2 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("  <apply>\n" + 
    "    <power/>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 2 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_POWER)
    n1 = libsbml.ASTNode(libsbml.AST_NAME)
    n1.setName("x")
    n2 = libsbml.ASTNode()
    n2.setValue(2.0)
    self.N.addChild(n1)
    self.N.addChild(n2)
    replaced = libsbml.ASTNode(libsbml.AST_PLUS)
    c = libsbml.ASTNode()
    c.setValue(1.0)
    replaced.addChild(c)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(original,self.S) )
    self.N.replaceIDWithFunction("x",replaced)
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    replaced = None
    pass  

  def test_MathMLFromAST_root(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_ROOT)
    c1_1 = libsbml.ASTNode(libsbml.AST_INTEGER)
    self.assertTrue( c1_1.setValue(3) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1_1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_root1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> y </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    expected1 = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> y </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x1 </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_ROOT)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c1.setName("y") == libsbml.LIBSBML_OPERATION_SUCCESS )
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c1) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c3.setName("x1") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c3) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected1,self.S) )
    pass  

  def test_MathMLFromAST_root2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_ROOT)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    self.assertTrue( c2.setName("x") == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.addChild(c2) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_MathMLFromAST_sin(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <sin/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_SIN)
    c = libsbml.ASTNode(libsbml.AST_INTEGER)
    c.setValue(long)
    self.assertTrue( self.N.addChild(c) == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

def suite():
  suite = unittest.TestSuite()
  suite.addTest(unittest.makeSuite(TestWriteMathMLFromAST))

  return suite

if __name__ == "__main__":
  if unittest.TextTestRunner(verbosity=1).run(suite()).wasSuccessful() :
    sys.exit(0)
  else:
    sys.exit(1)
