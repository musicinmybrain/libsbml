#
# @file    TestChildFunctions.py
# @brief   MathML unit tests for child manipulation functions
#
# @author  Akiya Jouraku (Python conversion)
# @author  Sarah Keating 
# 
# ====== WARNING ===== WARNING ===== WARNING ===== WARNING ===== WARNING ======
#
# DO NOT EDIT THIS FILE.
#
# This file was generated automatically by converting the file located at
# src/sbml/test/TestChildFunctions.cpp
# using the conversion program dev/utilities/translateTests/translateTests.pl.
# Any changes made here will be lost the next time the file is regenerated.
#
# -----------------------------------------------------------------------------
# This file is part of libSBML.  Please visit http://sbml.org for more
# information about SBML, and the latest version of libSBML.
#
# Copyright 2005-2010 California Institute of Technology.
# Copyright 2002-2005 California Institute of Technology and
#                     Japan Science and Technology Corporation.
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation.  A copy of the license agreement is provided
# in the file named "LICENSE.txt" included with this software distribution
# and also available online as http://sbml.org/software/libsbml/license.html
# -----------------------------------------------------------------------------

import sys
import unittest
import libsbml

def MATHML_FOOTER():
  return "</math>"
  pass

def MATHML_HEADER():
  return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n"
  pass

def MATHML_HEADER_UNITS():
  return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\""
  pass

def MATHML_HEADER_UNITS2():
  return " xmlns:sbml=\"http://www.sbml.org/sbml/level3/version2/core\">\n"
  pass

def XML_HEADER():
  return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  pass

def wrapMathML(s):
  r = XML_HEADER()
  r += MATHML_HEADER()
  r += s
  r += MATHML_FOOTER()
  return r
  pass

def wrapMathMLUnits(s):
  r = XML_HEADER()
  r += MATHML_HEADER_UNITS()
  r += MATHML_HEADER_UNITS2()
  r += s
  r += MATHML_FOOTER()
  return r
  pass


class TestChildFunctions(unittest.TestCase):

  global S
  S = None
  global N
  N = None

  def setUp(self):
    self.N = None
    self.S = None
    pass  

  def tearDown(self):
    self.N = None
    self.S = None
    pass  

  def test_ChildFunctions_addToLambda_1(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "  <bvar> <ci>x</ci> </bvar>" + 
    "  <ci>y</ci>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToLog_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToLog_2(self):
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn sbml:units=\"dimensionless\" type=\"integer\"> 10 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToLog_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_LOG)
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToPiecewise_1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToPiecewise_2(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <ci> newChild1 </ci>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    newChild1 = libsbml.ASTNode(libsbml.AST_NAME)
    newChild1.setName("newChild1")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    i = self.N.addChild(newChild1)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 4 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToPiecewise_3(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <true/>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 1 )
    newChild = libsbml.ASTNode(libsbml.AST_CONSTANT_TRUE)
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToRoot_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToRoot_2(self):
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn sbml:units=\"dimensionless\" type=\"integer\"> 2 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_addToRoot_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_ROOT)
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.addChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_getChild(self):
    self.N = libsbml.ASTNode(libsbml.AST_TIMES)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("c1")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    c2.setName("c2")
    self.N.addChild(c2)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(2)
    self.assertTrue( child == None )
    child = self.N.getChild(3)
    self.assertTrue( child == None )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "c2" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromLambda_1(self):
    original = wrapMathML("<lambda>" + 
    "  <bvar> <ci>x</ci> </bvar>" + 
    "  <apply> <cos/><ci>x</ci></apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(3)
    self.assertTrue( child == None )
    child = self.N.getChild(2)
    self.assertTrue( child == None )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    self.assertTrue( child.representsBvar() == True )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_FUNCTION_COS )
    self.assertTrue( child.getNumChildren() == 1 )
    self.assertTrue( child.representsBvar() == False )
    child1 = child.getChild(0)
    self.assertTrue( child1.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child1.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromLambda_2(self):
    self.N = libsbml.ASTNode(libsbml.AST_LAMBDA)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("y")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_FUNCTION_ABS)
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    c3.setName("y")
    c2.addChild(c3)
    self.N.addChild(c2)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(3)
    self.assertTrue( child == None )
    child = self.N.getChild(2)
    self.assertTrue( child == None )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "y" != child.getName() ) == False )
    self.assertTrue( child.representsBvar() == True )
    child = self.N.getChild(1)
    self.assertTrue( child.representsBvar() == False )
    self.assertTrue( child.getType() == libsbml.AST_FUNCTION_ABS )
    self.assertTrue( child.getNumChildren() == 1 )
    child1 = child.getChild(0)
    self.assertTrue( child1.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "y" != child1.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromLog_1(self):
    original = wrapMathML("<apply> <log/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertTrue( child.getInteger() == 10 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromLog_2(self):
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertTrue( child.getInteger() == 3 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromPiecewise_1(self):
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci>y</ci>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    child = self.N.getChild(4)
    self.assertTrue( child == None )
    child = self.N.getChild(3)
    self.assertTrue( child == None )
    child = self.N.getChild(2)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_RELATIONAL_EQ )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "y" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromPiecewise_2(self):
    self.N = libsbml.ASTNode(libsbml.AST_FUNCTION_PIECEWISE)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("y")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_CONSTANT_TRUE)
    self.N.addChild(c2)
    c3 = libsbml.ASTNode(libsbml.AST_NAME)
    c3.setName("x")
    self.N.addChild(c3)
    self.assertTrue( self.N.getNumChildren() == 3 )
    child = self.N.getChild(4)
    self.assertTrue( child == None )
    child = self.N.getChild(3)
    self.assertTrue( child == None )
    child = self.N.getChild(2)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_CONSTANT_TRUE )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "y" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromRoot_1(self):
    original = wrapMathML("<apply> <root/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertTrue( child.getInteger() == 2 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_getChildFromRoot_2(self):
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertTrue( child.getInteger() == 3 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "x" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_insert(self):
    self.N = libsbml.ASTNode(libsbml.AST_TIMES)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("c1")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    c2.setName("c2")
    self.N.addChild(c2)
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    newChild1 = libsbml.ASTNode(libsbml.AST_NAME)
    newChild1.setName("newChild1")
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(2,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    math = libsbml.formulaToString(self.N)
    self.assertTrue( (  "c1 * c2 * newChild" != math ) == False )
    i = self.N.insertChild(1,newChild1)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 4 )
    math = libsbml.formulaToString(self.N)
    self.assertTrue( (  "c1 * newChild1 * c2 * newChild" != math ) == False )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "newChild1" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_insertIntoLambda_1(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <ci>y</ci>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 1 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(2,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoLambda_2(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 1 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(1,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoLambda_3(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 1 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(0,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoLog_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(2,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoLog_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(1,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoLog_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </logbase>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(0,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoPiecewise_1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(2,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoPiecewise_2(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(1,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoPiecewise_3(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.prependChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoPiecewise_4(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <apply>\n" + 
    "        <plus/>\n" + 
    "        <ci> a </ci>\n" + 
    "        <ci> b </ci>\n" + 
    "      </apply>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.parseFormula("a + b")
    i = self.N.prependChild(newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoRoot_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(3,newChild)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.insertChild(2,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoRoot_2(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(1,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_insertIntoRoot_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.insertChild(0,newChild)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.S = libsbml.writeMathMLToString(self.N)
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_remove(self):
    self.N = libsbml.ASTNode(libsbml.AST_TIMES)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("c1")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    c2.setName("c2")
    self.N.addChild(c2)
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(2)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(0)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "c2" != child.getName() ) == False )
    _dummyList = [ c1 ]; _dummyList[:] = []; del _dummyList
    pass  

  def test_ChildFunctions_removeFromLambda_1(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 1 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLambda_2(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 1 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLambda_3(self):
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.assertTrue( self.N.getChild(2).representsBvar() == False )
    removed = self.N.getChild(2)
    i = self.N.removeChild(2)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.assertTrue( self.N.getNumBvars() == 2 )
    self.assertTrue( self.N.getChild(0).representsBvar() == True )
    self.assertTrue( self.N.getChild(1).representsBvar() == True )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLog_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLog_2(self):
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLog_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromLog_4(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromPiecewise_1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <gt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <apply> <cos/> <ci>x</ci> </apply>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <ci>x</ci>" + 
    "    <apply> <gt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 6 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 5 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 4 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromPiecewise_2(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    removed = self.N.getChild(2)
    i = self.N.removeChild(2)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromPiecewise_3(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <otherwise>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromRoot_1(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromRoot_2(self):
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <root/>\n" + 
    "    <cn sbml:units=\"dimensionless\" type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.removeChild(3)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = self.N.getChild(1)
    i = self.N.removeChild(1)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_INTEGER )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromRoot_3(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_removeFromRoot_4(self):
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    removed = self.N.getChild(0)
    i = self.N.removeChild(0)
    removed = None
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 1 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_replace(self):
    self.N = libsbml.ASTNode(libsbml.AST_TIMES)
    c1 = libsbml.ASTNode(libsbml.AST_NAME)
    c1.setName("c1")
    self.N.addChild(c1)
    c2 = libsbml.ASTNode(libsbml.AST_NAME)
    c2.setName("c2")
    self.N.addChild(c2)
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.replaceChild(3,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.replaceChild(2,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.replaceChild(1,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "newChild" != child.getName() ) == False )
    pass  

  def test_ChildFunctions_replaceInPiecewise_1(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 2 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.replaceChild(3,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.replaceChild(2,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 2 )
    i = self.N.replaceChild(0,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 2 )
    child = self.N.getChild(0)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "newChild" != child.getName() ) == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_replaceInPiecewise_2(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <otherwise> <ci> x </ci> </otherwise>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    newChild = libsbml.ASTNode(libsbml.AST_NAME)
    newChild.setName("newChild")
    i = self.N.replaceChild(4,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 3 )
    i = self.N.replaceChild(3,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_INDEX_EXCEEDS_SIZE )
    self.assertTrue( self.N.getNumChildren() == 3 )
    i = self.N.replaceChild(2,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    child = self.N.getChild(2)
    self.assertTrue( child.getType() == libsbml.AST_NAME )
    self.assertTrue( (  "newChild" != child.getName() ) == False )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_replaceInPiecewise_3(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <plus/>\n" + 
    "        <ci> a </ci>\n" + 
    "        <ci> b </ci>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <otherwise> <ci> x </ci> </otherwise>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 3 )
    newChild = libsbml.parseFormula("a + b")
    i = self.N.replaceChild(1,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 3 )
    child = self.N.getChild(1)
    self.assertTrue( child.getType() == libsbml.AST_PLUS )
    self.assertTrue( child.getNumChildren() == 2 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

  def test_ChildFunctions_replaceInPiecewise_4(self):
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <apply>\n" + 
    "        <cos/>\n" + 
    "        <ci> x </ci>\n" + 
    "      </apply>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "      <apply>\n" + 
    "        <gt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <apply> <cos/> <ci>x</ci> </apply>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <ci>x</ci>" + 
    "    <apply> <gt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    self.N = libsbml.readMathMLFromString(original)
    self.assertTrue( self.N.getNumChildren() == 6 )
    newChild = libsbml.parseFormula("3")
    i = self.N.replaceChild(4,newChild,True)
    self.assertTrue( i == libsbml.LIBSBML_OPERATION_SUCCESS )
    self.assertTrue( self.N.getNumChildren() == 6 )
    self.S = libsbml.writeMathMLToString(self.N)
    self.assertEqual( True, self.equals(expected,self.S) )
    pass  

def suite():
  suite = unittest.TestSuite()
  suite.addTest(unittest.makeSuite(TestChildFunctions))

  return suite

if __name__ == "__main__":
  if unittest.TextTestRunner(verbosity=1).run(suite()).wasSuccessful() :
    sys.exit(0)
  else:
    sys.exit(1)
