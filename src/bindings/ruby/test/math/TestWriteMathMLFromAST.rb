# @file    TestWriteMathMLFromAST.rb
# @brief   Write MathML unit tests starting from ASTNodes
#
# @author  Akiya Jouraku (Ruby conversion)
# @author  Sarah Keating 
# 
# ====== WARNING ===== WARNING ===== WARNING ===== WARNING ===== WARNING ======
#
# DO NOT EDIT THIS FILE.
#
# This file was generated automatically by converting the file located at
# src/sbml/test/TestWriteMathMLFromAST.cpp
# using the conversion program dev/utilities/translateTests/translateTests.pl.
# Any changes made here will be lost the next time the file is regenerated.
#
# -----------------------------------------------------------------------------
# This file is part of libSBML.  Please visit http://sbml.org for more
# information about SBML, and the latest version of libSBML.
#
# Copyright 2005-2010 California Institute of Technology.
# Copyright 2002-2005 California Institute of Technology and
#                     Japan Science and Technology Corporation.
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation.  A copy of the license agreement is provided
# in the file named "LICENSE.txt" included with this software distribution
# and also available online as http://sbml.org/software/libsbml/license.html
# -----------------------------------------------------------------------------
require 'test/unit'
require 'libSBML'

class TestWriteMathMLFromAST < Test::Unit::TestCase

  def MATHML_FOOTER
    return "</math>"
  end

  def MATHML_HEADER
    return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n"
  end

  def MATHML_HEADER_UNITS
    return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\""
  end

  def MATHML_HEADER_UNITS2
    return " xmlns:sbml=\"http://www.sbml.org/sbml/level3/version2/core\">\n"
  end

  def XML_HEADER
    return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  end

  def wrapMathML(s)
    r = XML_HEADER()
    r += MATHML_HEADER()
    r += s
    r += MATHML_FOOTER()
    return r
  end

  def wrapMathMLUnits(s)
    r = XML_HEADER()
    r += MATHML_HEADER_UNITS()
    r += MATHML_HEADER_UNITS2()
    r += s
    r += MATHML_FOOTER()
    return r
  end

  def setup
    @@n = nil
    @@s = nil
  end

  def teardown
    @@n = nil
    @@s = nil
  end

  def test_MathMLFromAST_ci
    expected = wrapMathML("  <ci> foo </ci>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    @@n.setName("foo")
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_ci_class
    expected = wrapMathML("  <ci class=\"test\"> foo </ci>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    @@n.setName("foo")
    assert( @@n.setClass("test") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_ci_definitionURL
    expected = wrapMathML("  <ci definitionURL=\"http://someurl\"> foo </ci>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    @@n.setName("foo")
    xml = LibSBML::XMLAttributes.new()
    xml.add("", "http://someurl")
    @@n.setDefinitionURL(xml)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_ci_id
    expected = wrapMathML("  <ci id=\"test\"> foo </ci>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    @@n.setName("foo")
    assert( @@n.setId("test") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_ci_style
    expected = wrapMathML("  <ci style=\"test\"> foo </ci>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    @@n.setName("foo")
    assert( @@n.setStyle("test") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_1
    expected = wrapMathML("  <cn type=\"e-notation\"> 0 <sep/> 3 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(0.0,3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_2
    expected = wrapMathML("  <cn> 2000 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(2e3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_3
    expected = wrapMathML("  <cn type=\"e-notation\"> 1234567.8 <sep/> 3 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(1234567.8,3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_4
    expected = wrapMathML("  <cn type=\"e-notation\"> 6.0221367 <sep/> 23 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(6.0221367,23)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_5
    expected = wrapMathML("  <cn type=\"e-notation\"> 4 <sep/> -6 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(0.000004)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_6
    expected = wrapMathML("  <cn type=\"e-notation\"> 4 <sep/> -12 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(0.000004,-6)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_e_notation_7
    expected = wrapMathML("  <cn type=\"e-notation\"> -1 <sep/> -6 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL_E)
    @@n.setValue(-1.0,-6)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_integer
    expected = wrapMathML("  <cn type=\"integer\"> 5 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    @@n.setValue((long)(5))
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_rational
    expected = wrapMathML("  <cn type=\"rational\"> 1 <sep/> 3 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_RATIONAL)
    @@n.setValue(long,3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_real_1
    expected = wrapMathML("  <cn> 1.2 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(1.2)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_real_2
    expected = wrapMathML("  <cn> 1234567.8 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(1234567.8)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_real_3
    expected = wrapMathML("  <cn> -3.14 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(-3.14)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_real_locale
    expected = wrapMathML("  <cn> 2.72 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(2.72)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_cn_units
    expected = wrapMathMLUnits("  <cn sbml:units=\"mole\"> 1.2 </cn>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(1.2)
    @@n.setUnits("mole")
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_exponentiale
    expected = wrapMathML("  <exponentiale/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_E)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_false
    expected = wrapMathML("  <false/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_FALSE)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_infinity
    expected = wrapMathML("  <infinity/>\n")
    @@n = LibSBML::ASTNode.new()
    @@n.setValue( util_PosInf() )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_infinity_neg
    expected = wrapMathML("  <apply> <minus/> <infinity/> </apply>\n"  
    )
    @@n = LibSBML::ASTNode.new()
    @@n.setValue(- util_PosInf())
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_infinity_neg1
    expected = wrapMathML("  <apply> <minus/> <infinity/> </apply>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue(- util_PosInf())
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_notanumber
    expected = wrapMathML("  <notanumber/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    @@n.setValue( util_NaN() )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_pi
    expected = wrapMathML("  <pi/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_PI)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_constant_true
    expected = wrapMathML("  <true/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_TRUE)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_csymbol_avogadro
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/avogadro\"> NA </csymbol>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME_AVOGADRO)
    @@n.setName("NA")
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_csymbol_delay
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/delay\"> my_delay </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 0.1 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_DELAY)
    assert( @@n.setName("my_delay") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c1.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    assert( c2.setValue(0.1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_csymbol_rateof
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/rateOf\"> my_delay </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_RATE_OF)
    assert( @@n.setName("my_delay") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c1.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_csymbol_time
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/time\"> t </csymbol>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME_TIME)
    @@n.setName("t")
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_csymbol_time_no_name
    expected = wrapMathML("  <csymbol encoding=\"text\" " + "definitionURL=\"http://www.sbml.org/sbml/symbols/time\"/>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_NAME_TIME)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_func_style
    expected = wrapMathML("  <apply>\n" + 
    "    <sin style=\"a\"/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_SIN)
    @@n.setStyle("a")
    c = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c.setValue((int)(1))
    @@n.addChild(c)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_function_1
    expected = wrapMathML("  <apply>\n" + 
    "    <ci> foo </ci>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION)
    assert( @@n.setName("foo") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c3) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_function_2
    expected = wrapMathML("  <apply>\n" + 
    "    <ci> foo </ci>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <apply>\n" + 
    "      <ci> bar </ci>\n" + 
    "      <ci> z </ci>\n" + 
    "    </apply>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION)
    assert( @@n.setName("foo") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    bar = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION)
    bar.setName("bar")
    cz = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    cz.setName("z")
    assert( bar.addChild(cz) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(bar) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_generic_csymbol
    expected = wrapMathML("  <apply>\n" + 
    "    <csymbol encoding=\"text\" definitionURL=\"http://www.sbml.org/sbml/" + 
    "symbols/some/unknown/URL\"> unknown_function </csymbol>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 0.1 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_CSYMBOL_FUNCTION)
    assert( @@n.setName("unknown_function") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.setDefinitionURL("http://www.sbml.org/sbml/symbols/some/unknown/URL") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c1.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_REAL)
    assert( c2.setValue(0.1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_implies
    expected = wrapMathML("  <apply>\n" + 
    "    <implies/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_LOGICAL_IMPLIES)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c3) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_lambda
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_LAMBDA)
    c1_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1_1.setName("x")
    c2_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2_1.setName("y")
    c3 = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c3_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3_1.setName("x")
    c3_2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3_2.setName("y")
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    @@n.addChild(c1_1)
    @@n.addChild(c2_1)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_lambda1
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_LAMBDA)
    c1_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1_1.setName("x")
    c2_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2_1.setName("y")
    c3 = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c3_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3_1.setName("x")
    c3_2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3_2.setName("y")
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    @@n.addChild(c1_1)
    @@n.addChild(c2_1)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_lambda_no_bvars
    expected = wrapMathML("  <lambda>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_LAMBDA)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c3_1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3_1.setValue(2)
    c3_2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3_2.setValue(2)
    c3.addChild(c3_1)
    c3.addChild(c3_2)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_log
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 2 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_LOG)
    c1_1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    assert( c1_1.setValue(2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1_1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("N") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_log_2
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <ci> x </ci>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_LOG)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c1.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("N") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_log_3
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_LOG)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("N") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_log_4
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 10 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> N </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_LOG)
    c1_1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    assert( c1_1.setValue(10) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1_1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("N") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c3.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c3) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_max
    expected = wrapMathML("  <apply>\n" + 
    "    <max/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_MAX)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_min
    expected = wrapMathML("  <apply>\n" + 
    "    <min/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_MIN)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_minus
    expected = wrapMathML("  <apply>\n" + 
    "    <minus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_MINUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_minus_unary_1
    expected = wrapMathML("  <cn type=\"integer\"> -2 </cn>\n"  
    )
    @@n = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    @@n.setValue(-2)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_minus_unary_2
    expected = wrapMathML("  <apply>\n" + 
    "    <minus/>\n" + 
    "    <ci> a </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_MINUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("a")
    @@n.addChild(c1)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_nested_funcs
    expected = wrapMathML("  <apply>\n" + 
    "    <divide/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <apply>\n" + 
    "      <sin/>\n" + 
    "      <cn type=\"rational\"> 3 <sep/> 5 </cn>\n" + 
    "    </apply>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_DIVIDE)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_RATIONAL)
    c2.setValue(long,long)
    sin = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_SIN)
    sin.addChild(c2)
    @@n.addChild(c1)
    @@n.addChild(sin)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_piecewise1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n"  + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_PIECEWISE)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(0)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_RELATIONAL_LT)
    c2_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2_1.setName("x")
    c2_2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2_2.setValue(0)
    c2.addChild(c2_1)
    c2.addChild(c2_2)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(0)
    c4 = LibSBML::ASTNode.new(LibSBML::AST_RELATIONAL_EQ)
    c4_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c4_1.setName("x")
    c4_4 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c4_4.setValue(0)
    c4.addChild(c4_1)
    c4.addChild(c4_4)
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@n.addChild(c3)
    @@n.addChild(c4)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_piecewise_no_piece1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n"  + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_PIECEWISE)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3.setName("x")
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_piecewise_otherwise1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn type=\"integer\"> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n"  + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_PIECEWISE)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(0)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_RELATIONAL_LT)
    c2_1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2_1.setName("x")
    c2_2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2_2.setValue(0)
    c2.addChild(c2_1)
    c2.addChild(c2_2)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3.setName("x")
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_binary
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_nary_1
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_nary_2
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    plus = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    plus.addChild(c1)
    plus.addChild(c2)
    @@n.addChild(plus)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_nary_3
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    plus = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    plus.addChild(c2)
    plus.addChild(c3)
    @@n.addChild(c1)
    @@n.addChild(plus)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_nary_4
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "    <apply>\n" + 
    "      <times/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "      <ci> z </ci>\n" + 
    "    </apply>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(long)
    cx = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    cx.setName("x")
    cy = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    cy.setName("y")
    cz = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    cz.setName("z")
    times = LibSBML::ASTNode.new(LibSBML::AST_TIMES)
    times.addChild(cx)
    times.addChild(cy)
    times.addChild(cz)
    @@n.addChild(c1)
    @@n.addChild(c2)
    @@n.addChild(times)
    @@n.addChild(c3)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_plus_nary_5
    expected = wrapMathML("  <apply>\n" + 
    "    <plus/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 4 </cn>\n" + 
    "    <cn type=\"integer\"> 5 </cn>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(2)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c3.setValue(3)
    c4 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c4.setValue(4)
    c5 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c5.setValue(5)
    plus = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    plus.addChild(c4)
    plus.addChild(c5)
    plus1 = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    plus1.addChild(plus)
    plus1.addChild(c3)
    plus2 = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    plus2.addChild(plus1)
    plus2.addChild(c2)
    @@n.addChild(c1)
    @@n.addChild(plus2)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_quotient
    expected = wrapMathML("  <apply>\n" + 
    "    <quotient/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_QUOTIENT)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_rem
    expected = wrapMathML("  <apply>\n" + 
    "    <rem/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "    <cn type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_REM)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c1.setValue(long)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c2.setValue(long)
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_replaceIDWithFunction_2
    expected = wrapMathML("  <apply>\n" + 
    "    <power/>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <cn> 1 </cn>\n" + 
    "    </apply>\n" + 
    "    <cn> 2 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("  <apply>\n" + 
    "    <power/>\n" + 
    "    <ci> x </ci>\n" + 
    "    <cn> 2 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_POWER)
    n1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    n1.setName("x")
    n2 = LibSBML::ASTNode.new()
    n2.setValue(2.0)
    @@n.addChild(n1)
    @@n.addChild(n2)
    replaced = LibSBML::ASTNode.new(LibSBML::AST_PLUS)
    c = LibSBML::ASTNode.new()
    c.setValue(1.0)
    replaced.addChild(c)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(original,@@s)
    @@n.replaceIDWithFunction("x",replaced)
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
    replaced = nil
  end

  def test_MathMLFromAST_root
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_ROOT)
    c1_1 = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    assert( c1_1.setValue(3) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1_1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_root1
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> y </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    expected1 = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> y </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x1 </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_ROOT)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c1.setName("y") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c1) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c3.setName("x1") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c3) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected1,@@s)
  end

  def test_MathMLFromAST_root2
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_ROOT)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    assert( c2.setName("x") == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.addChild(c2) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_MathMLFromAST_sin
    expected = wrapMathML("  <apply>\n" + 
    "    <sin/>\n" + 
    "    <cn type=\"integer\"> 1 </cn>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_SIN)
    c = LibSBML::ASTNode.new(LibSBML::AST_INTEGER)
    c.setValue(long)
    assert( @@n.addChild(c) == LibSBML::LIBSBML_OPERATION_SUCCESS )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

end
