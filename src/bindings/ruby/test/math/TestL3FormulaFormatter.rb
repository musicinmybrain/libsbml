# @file    TestL3FormulaFormatter.rb
# @brief   FormulaFormatter unit tests
#
# @author  Akiya Jouraku (Ruby conversion)
# @author  Lucian Smith, from Ben Bornstein 
# 
# ====== WARNING ===== WARNING ===== WARNING ===== WARNING ===== WARNING ======
#
# DO NOT EDIT THIS FILE.
#
# This file was generated automatically by converting the file located at
# src/sbml/test/TestL3FormulaFormatter.c
# using the conversion program dev/utilities/translateTests/translateTests.pl.
# Any changes made here will be lost the next time the file is regenerated.
#
# -----------------------------------------------------------------------------
# This file is part of libSBML.  Please visit http://sbml.org for more
# information about SBML, and the latest version of libSBML.
#
# Copyright 2005-2010 California Institute of Technology.
# Copyright 2002-2005 California Institute of Technology and
#                     Japan Science and Technology Corporation.
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation.  A copy of the license agreement is provided
# in the file named "LICENSE.txt" included with this software distribution
# and also available online as http://sbml.org/software/libsbml/license.html
# -----------------------------------------------------------------------------
require 'test/unit'
require 'libSBML'

class TestL3FormulaFormatter < Test::Unit::TestCase

  def test_L3FormulaFormatter_accessWithNULL
    nil.format(nil,nil)
    nil.formatFunction(nil,nil)
    nil.formatOperator(nil)
    nil.visit(nil,nil,nil)
    nil.visitFunction(nil,nil,nil)
    nil.visitLog10(nil,nil,nil)
    nil.visitOther(nil,nil,nil)
    nil.visitSqrt(nil,nil,nil)
    nil.visitUMinus(nil,nil,nil)
    assert( nil.isFunction(nil) == 0 )
    assert( nil.isGrouped(nil,nil) == 0 )
    s = nil.formulaToL3String()
    assert( s == nil )
  end

  def test_L3FormulaFormatter_collapseMinus
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    c2 = LibSBML::ASTNode.new()
    c3 = LibSBML::ASTNode.new()
    c4 = LibSBML::ASTNode.new()
    l3ps = LibSBML::L3ParserSettings.new()
    n.setType(LibSBML::AST_MINUS)
    c.setType(LibSBML::AST_MINUS)
    n.addChild(c)
    c2.setType(LibSBML::AST_MINUS)
    c.addChild(c2)
    c3.setType(LibSBML::AST_MINUS)
    c2.addChild(c3)
    c4.setName( "x")
    c3.addChild(c4)
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "----x" == s ))
    l3ps.setParseCollapseMinus(0)
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "----x" == s ))
    l3ps.setParseCollapseMinus(1)
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "x" == s ))
    n = nil
    l3ps = nil
  end

  def test_L3FormulaFormatter_isFunction
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_NAME)
    assert( n.isFunction(nil) == 0 )
    n.setType(LibSBML::AST_CONSTANT_PI)
    assert( n.isFunction(nil) == 0 )
    n.setType(LibSBML::AST_LAMBDA)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_FUNCTION)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_LOGICAL_AND)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_RELATIONAL_EQ)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_PLUS)
    assert( n.isFunction(nil) == 1 )
    n.addChild(c)
    n.setType(LibSBML::AST_LOGICAL_AND)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_RELATIONAL_EQ)
    assert( n.isFunction(nil) == 1 )
    n.setType(LibSBML::AST_PLUS)
    assert( n.isFunction(nil) == 1 )
    c = LibSBML::ASTNode.new()
    n.addChild(c)
    n.setType(LibSBML::AST_LOGICAL_AND)
    assert( n.isFunction(nil) == 0 )
    n.setType(LibSBML::AST_RELATIONAL_EQ)
    assert( n.isFunction(nil) == 0 )
    n.setType(LibSBML::AST_PLUS)
    assert( n.isFunction(nil) == 0 )
    n = nil
  end

  def test_L3FormulaFormatter_isGrouped
    p = LibSBML::ASTNode.new()
    assert( nil.isGrouped(p,nil) == 0 )
    p = nil
    p = "1 + 2 * 3".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "(1 + 2) * 3".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 1 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "1 + (2 * 3)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "foo(1 + 2, 2 * 3)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "(a / b) * c".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 1 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "a / (b * c)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 1 )
    p = nil
    p = "a - (b - c)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 1 )
    p = nil
    p = "a - b - c".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "a + (b + c)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 1 )
    p = nil
    p = "a + b + c".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "a * (b * c)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 1 )
    p = nil
    p = "a * b * c".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
    p = "a / (b / c)".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 1 )
    p = nil
    p = "a / b / c".parseL3Formula()
    c = p.getLeftChild()
    assert( p.isGrouped(c,nil) == 0 )
    c = p.getRightChild()
    assert( p.isGrouped(c,nil) == 0 )
    p = nil
  end

  def test_L3FormulaFormatter_multiAnd
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_LOGICAL_AND)
    s = n.formulaToL3String()
    assert ((  "and()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "and(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x && y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x && y && z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiDivide
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_DIVIDE)
    s = n.formulaToL3String()
    assert ((  "divide()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "divide(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x / y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "divide(x, y, z)" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiEq
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_RELATIONAL_EQ)
    s = n.formulaToL3String()
    assert ((  "eq()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "eq(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x == y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x == y == z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiGT
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_RELATIONAL_GT)
    s = n.formulaToL3String()
    assert ((  "gt()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "gt(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x > y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x > y > z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiNEq
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_RELATIONAL_NEQ)
    s = n.formulaToL3String()
    assert ((  "neq()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "neq(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x != y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "neq(x, y, z)" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiOr
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_LOGICAL_OR)
    s = n.formulaToL3String()
    assert ((  "or()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "or(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x || y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x || y || z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiPlus
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_PLUS)
    s = n.formulaToL3String()
    assert ((  "plus()" == s ))
    c.setName( "x")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "plus(x)" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x + y" == s ))
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x + y + z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_multiPlusTimes
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_PLUS)
    c.setName( "x")
    n.addChild(c)
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    c = LibSBML::ASTNode.new()
    c.setName( "z")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x + y + z" == s ))
    n.setType(LibSBML::AST_TIMES)
    s = n.formulaToL3String()
    assert ((  "x * y * z" == s ))
    n = nil
  end

  def test_L3FormulaFormatter_parseUnits
    n = LibSBML::ASTNode.new()
    l3ps = LibSBML::L3ParserSettings.new()
    n.setValue(1.1)
    n.setUnits( "mL")
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "1.1 mL" == s ))
    l3ps.setParseUnits(0)
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "1.1" == s ))
    l3ps.setParseUnits(1)
    s = n.formulaToL3StringWithSettings(l3ps)
    assert ((  "1.1 mL" == s ))
    n = nil
    l3ps = nil
  end

  def test_L3FormulaFormatter_semantics
    n = LibSBML::ASTNode.new()
    c = LibSBML::ASTNode.new()
    n.setType(LibSBML::AST_LOGICAL_OR)
    c.setName( "x")
    n.addChild(c)
    c = LibSBML::ASTNode.new()
    c.setName( "y")
    n.addChild(c)
    s = n.formulaToL3String()
    assert ((  "x || y" == s ))
    xml = LibSBML::XMLNode.convertStringToXMLNode("<annotation> a </annotation>",nil)
    n.addSemanticsAnnotation(xml)
    s = n.formulaToL3String()
    assert ((  "x || y" == s ))
    n = nil
  end

  def test_SBML_formulaToL3String
    const char *formulae[] ={"1""2.1""2.101e-10""foo""1 + foo""1 + 2""1 + 2 * 3""(1 - 2) * 3""1 + -2 / 3""1 + -2e-100 / 3""1 - -foo / 3""2 * foo^bar + 3.1""foo()""foo(1)""foo(1, bar)""foo(1, bar, 2^-3)""(a / b) * c""a / (b * c)""1 + 2 + 3""a * (b * c)""a + (b + c)""a * b * c""a + b + c""x % y""(1 + x) % (3 / y)""(x^2) % -y""x && (y == z)""(x && y) == z""(a && b) || c""a && (b || c)""a && b && c""a || b || c""-x^y""(-x)^y""x^-y""!(x^2)""(!x)^2""x^!2""1 ml""(3/4) uM""INF""NaN""avogadro""time""pi""true""false""(x > y) + (p == q)""(x > y > z) + (p == d == q)""(x || y) > (p && q)""or(x) > and(p)""or() > and()""(x * y)^2""(x * y * z)^2""times(x)^2""times()^2"""  
    }
    s = n.formulaToL3String()
    assert (( formulae[i] == s ))
    n = nil
  end
end

  def test_SBML_formulaToL3String_L1toL3
    n = "acos(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "acos(x)" == s ))
    n = nil
    n = "asin(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "asin(x)" == s ))
    n = nil
    n = "atan(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "atan(x)" == s ))
    n = nil
    n = "ceil(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "ceil(x)" == s ))
    n = nil
    n = "log(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "log10(x)" == s ))
    n = nil
    n = LibSBML::parseFormula("log(x)")
    s = n.formulaToL3String()
    assert ((  "ln(x)" == s ))
    n = nil
    n = "log10(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "log10(x)" == s ))
    n = nil
    n = "pow(x, y)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x^y" == s ))
    n = nil
    n = "sqr(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x^2" == s ))
    n = nil
    n = "sqrt(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "sqrt(x)" == s ))
    n = nil
    n = "x + (y + z)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x + (y + z)" == s ))
    n = nil
    n = "(x + y) + z".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x + y + z" == s ))
    n = nil
  end

  def test_SBML_formulaToL3String_L2toL3
    n = "arccos(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "acos(x)" == s ))
    n = nil
    n = "arcsin(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "asin(x)" == s ))
    n = nil
    n = "arctan(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "atan(x)" == s ))
    n = nil
    n = "ceiling(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "ceil(x)" == s ))
    n = nil
    n = "ln(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "ln(x)" == s ))
    n = nil
    n = "log(10, x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "log10(x)" == s ))
    n = nil
    n = "power(x, y)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x^y" == s ))
    n = nil
    n = "power(x, 2)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "x^2" == s ))
    n = nil
    n = "root(2, x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "sqrt(x)" == s ))
    n = nil
  end

  def test_SBML_formulaToL3String_L3v2
    n = "rateOf(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "rateOf(x)" == s ))
    n = nil
    n = "rem(x,y)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "rem(x, y)" == s ))
    n = nil
    n = "quotient(1,2)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "quotient(1, 2)" == s ))
    n = nil
    n = "max(a,b,5,8.4)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "max(a, b, 5, 8.4)" == s ))
    n = nil
    n = "min(x)".parseL3Formula()
    s = n.formulaToL3String()
    assert ((  "min(x)" == s ))
    n = nil
  end

end
