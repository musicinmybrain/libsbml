# @file    TestChildFunctions.rb
# @brief   MathML unit tests for child manipulation functions
#
# @author  Akiya Jouraku (Ruby conversion)
# @author  Sarah Keating 
# 
# ====== WARNING ===== WARNING ===== WARNING ===== WARNING ===== WARNING ======
#
# DO NOT EDIT THIS FILE.
#
# This file was generated automatically by converting the file located at
# src/sbml/test/TestChildFunctions.cpp
# using the conversion program dev/utilities/translateTests/translateTests.pl.
# Any changes made here will be lost the next time the file is regenerated.
#
# -----------------------------------------------------------------------------
# This file is part of libSBML.  Please visit http://sbml.org for more
# information about SBML, and the latest version of libSBML.
#
# Copyright 2005-2010 California Institute of Technology.
# Copyright 2002-2005 California Institute of Technology and
#                     Japan Science and Technology Corporation.
# 
# This library is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation.  A copy of the license agreement is provided
# in the file named "LICENSE.txt" included with this software distribution
# and also available online as http://sbml.org/software/libsbml/license.html
# -----------------------------------------------------------------------------
require 'test/unit'
require 'libSBML'

class TestChildFunctions < Test::Unit::TestCase

  def MATHML_FOOTER
    return "</math>"
  end

  def MATHML_HEADER
    return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n"
  end

  def MATHML_HEADER_UNITS
    return "<math xmlns=\"http://www.w3.org/1998/Math/MathML\""
  end

  def MATHML_HEADER_UNITS2
    return " xmlns:sbml=\"http://www.sbml.org/sbml/level3/version2/core\">\n"
  end

  def XML_HEADER
    return "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
  end

  def wrapMathML(s)
    r = XML_HEADER()
    r += MATHML_HEADER()
    r += s
    r += MATHML_FOOTER()
    return r
  end

  def wrapMathMLUnits(s)
    r = XML_HEADER()
    r += MATHML_HEADER_UNITS()
    r += MATHML_HEADER_UNITS2()
    r += s
    r += MATHML_FOOTER()
    return r
  end

  def setup
    @@n = nil
    @@s = nil
  end

  def teardown
    @@n = nil
    @@s = nil
  end

  def test_ChildFunctions_addToLambda_1
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "  <bvar> <ci>x</ci> </bvar>" + 
    "  <ci>y</ci>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToLog_1
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToLog_2
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn sbml:units=\"dimensionless\" type=\"integer\"> 10 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToLog_3
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_LOG)
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToPiecewise_1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToPiecewise_2
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <ci> newChild1 </ci>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    newChild1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild1.setName("newChild1")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    i = @@n.addChild(newChild1)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 4 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToPiecewise_3
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <true/>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 1 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_TRUE)
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToRoot_1
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToRoot_2
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn sbml:units=\"dimensionless\" type=\"integer\"> 2 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_addToRoot_3
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_ROOT)
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.addChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_getChild
    @@n = LibSBML::ASTNode.new(LibSBML::AST_TIMES)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("c1")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2.setName("c2")
    @@n.addChild(c2)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(2)
    assert( child == nil )
    child = @@n.getChild(3)
    assert( child == nil )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "c2" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromLambda_1
    original = wrapMathML("<lambda>" + 
    "  <bvar> <ci>x</ci> </bvar>" + 
    "  <apply> <cos/><ci>x</ci></apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(3)
    assert( child == nil )
    child = @@n.getChild(2)
    assert( child == nil )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
    assert( child.representsBvar() == true )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_FUNCTION_COS )
    assert( child.getNumChildren() == 1 )
    assert( child.representsBvar() == false )
    child1 = child.getChild(0)
    assert( child1.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child1.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromLambda_2
    @@n = LibSBML::ASTNode.new(LibSBML::AST_LAMBDA)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("y")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_ABS)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3.setName("y")
    c2.addChild(c3)
    @@n.addChild(c2)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(3)
    assert( child == nil )
    child = @@n.getChild(2)
    assert( child == nil )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "y" != child.getName() ) == false )
    assert( child.representsBvar() == true )
    child = @@n.getChild(1)
    assert( child.representsBvar() == false )
    assert( child.getType() == LibSBML::AST_FUNCTION_ABS )
    assert( child.getNumChildren() == 1 )
    child1 = child.getChild(0)
    assert( child1.getType() == LibSBML::AST_NAME )
    assert( (  "y" != child1.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromLog_1
    original = wrapMathML("<apply> <log/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert( child.getInteger() == 10 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromLog_2
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert( child.getInteger() == 3 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromPiecewise_1
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci>y</ci>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    child = @@n.getChild(4)
    assert( child == nil )
    child = @@n.getChild(3)
    assert( child == nil )
    child = @@n.getChild(2)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_RELATIONAL_EQ )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "y" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromPiecewise_2
    @@n = LibSBML::ASTNode.new(LibSBML::AST_FUNCTION_PIECEWISE)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("y")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_CONSTANT_TRUE)
    @@n.addChild(c2)
    c3 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c3.setName("x")
    @@n.addChild(c3)
    assert( @@n.getNumChildren() == 3 )
    child = @@n.getChild(4)
    assert( child == nil )
    child = @@n.getChild(3)
    assert( child == nil )
    child = @@n.getChild(2)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_CONSTANT_TRUE )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "y" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromRoot_1
    original = wrapMathML("<apply> <root/> " + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert( child.getInteger() == 2 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
  end

  def test_ChildFunctions_getChildFromRoot_2
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert( child.getInteger() == 3 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "x" != child.getName() ) == false )
  end

  def test_ChildFunctions_insert
    @@n = LibSBML::ASTNode.new(LibSBML::AST_TIMES)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("c1")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2.setName("c2")
    @@n.addChild(c2)
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    newChild1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild1.setName("newChild1")
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(2,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    math = LibSBML::formulaToString(@@n)
    assert( (  "c1 * c2 * newChild" != math ) == false )
    i = @@n.insertChild(1,newChild1)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 4 )
    math = LibSBML::formulaToString(@@n)
    assert( (  "c1 * newChild1 * c2 * newChild" != math ) == false )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "newChild1" != child.getName() ) == false )
  end

  def test_ChildFunctions_insertIntoLambda_1
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <ci>y</ci>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 1 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(2,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoLambda_2
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 1 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(1,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoLambda_3
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 1 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(0,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoLog_1
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(2,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoLog_2
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </logbase>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(1,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoLog_3
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "    <logbase>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </logbase>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(0,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoPiecewise_1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(2,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoPiecewise_2
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(1,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoPiecewise_3
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.prependChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoPiecewise_4
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <apply>\n" + 
    "        <plus/>\n" + 
    "        <ci> a </ci>\n" + 
    "        <ci> b </ci>\n" + 
    "      </apply>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::parseFormula("a + b")
    i = @@n.prependChild(newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoRoot_1
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> newChild </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(3,newChild)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.insertChild(2,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoRoot_2
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(1,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_insertIntoRoot_3
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <degree>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </degree>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.insertChild(0,newChild)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    @@s = LibSBML::writeMathMLToString(@@n)
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_INTEGER )
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_remove
    @@n = LibSBML::ASTNode.new(LibSBML::AST_TIMES)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("c1")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2.setName("c2")
    @@n.addChild(c2)
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(2)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(0)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "c2" != child.getName() ) == false )
    c1 = nil
  end

  def test_ChildFunctions_removeFromLambda_1
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 1 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLambda_2
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <apply>\n" + 
    "      <plus/>\n" + 
    "      <ci> x </ci>\n" + 
    "      <ci> y </ci>\n" + 
    "    </apply>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 1 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLambda_3
    expected = wrapMathML("  <lambda>\n" + 
    "    <bvar>\n" + 
    "      <ci> x </ci>\n" + 
    "    </bvar>\n" + 
    "    <bvar>\n" + 
    "      <ci> y </ci>\n" + 
    "    </bvar>\n" + 
    "  </lambda>\n")
    original = wrapMathML("<lambda>" + 
    "    <bvar> <ci>x</ci> </bvar>" + 
    "    <bvar> <ci>y</ci> </bvar>" + 
    "    <apply> <plus/> <ci>x</ci> <ci>y</ci> </apply>" + 
    "</lambda>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    assert( @@n.getChild(2).representsBvar() == false )
    removed = @@n.getChild(2)
    i = @@n.removeChild(2)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    assert( @@n.getNumBvars() == 2 )
    assert( @@n.getChild(0).representsBvar() == true )
    assert( @@n.getChild(1).representsBvar() == true )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLog_1
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLog_2
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLog_3
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/> <logbase> <cn type='integer'> 3 </cn> </logbase>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromLog_4
    expected = wrapMathML("  <apply>\n" + 
    "    <log/>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <log/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromPiecewise_1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <gt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <apply> <cos/> <ci>x</ci> </apply>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <ci>x</ci>" + 
    "    <apply> <gt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 6 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 5 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 4 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromPiecewise_2
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    removed = @@n.getChild(2)
    i = @@n.removeChild(2)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromPiecewise_3
    expected = wrapMathML("  <piecewise>\n" + 
    "    <otherwise>\n" + 
    "      <cn> 0 </cn>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromRoot_1
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <cn type=\"integer\"> 3 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromRoot_2
    expected = wrapMathMLUnits("  <apply>\n" + 
    "    <root/>\n" + 
    "    <cn sbml:units=\"dimensionless\" type=\"integer\"> 2 </cn>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    i = @@n.removeChild(3)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    removed = @@n.getChild(1)
    i = @@n.removeChild(1)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_INTEGER )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromRoot_3
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/> <degree> <cn type='integer'> 3 </cn> </degree>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_removeFromRoot_4
    expected = wrapMathML("  <apply>\n" + 
    "    <root/>\n" + 
    "    <ci> x </ci>\n" + 
    "  </apply>\n")
    original = wrapMathML("<apply> <root/>" + 
    "               <ci> x </ci>" + 
    "</apply>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    removed = @@n.getChild(0)
    i = @@n.removeChild(0)
    removed = nil
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 1 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_replace
    @@n = LibSBML::ASTNode.new(LibSBML::AST_TIMES)
    c1 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c1.setName("c1")
    @@n.addChild(c1)
    c2 = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    c2.setName("c2")
    @@n.addChild(c2)
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    assert( @@n.getNumChildren() == 2 )
    i = @@n.replaceChild(3,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.replaceChild(2,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.replaceChild(1,newChild,true)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "newChild" != child.getName() ) == false )
  end

  def test_ChildFunctions_replaceInPiecewise_1
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> newChild </ci>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 2 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.replaceChild(3,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.replaceChild(2,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 2 )
    i = @@n.replaceChild(0,newChild,true)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 2 )
    child = @@n.getChild(0)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "newChild" != child.getName() ) == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_replaceInPiecewise_2
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> newChild </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <otherwise> <ci> x </ci> </otherwise>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    newChild = LibSBML::ASTNode.new(LibSBML::AST_NAME)
    newchild.setName("newChild")
    i = @@n.replaceChild(4,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 3 )
    i = @@n.replaceChild(3,newChild,true)
    assert( i == LibSBML::LIBSBML_INDEX_EXCEEDS_SIZE )
    assert( @@n.getNumChildren() == 3 )
    i = @@n.replaceChild(2,newChild,true)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    child = @@n.getChild(2)
    assert( child.getType() == LibSBML::AST_NAME )
    assert( (  "newChild" != child.getName() ) == false )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_replaceInPiecewise_3
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <ci> x </ci>\n" + 
    "      <apply>\n" + 
    "        <plus/>\n" + 
    "        <ci> a </ci>\n" + 
    "        <ci> b </ci>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <otherwise>\n" + 
    "      <ci> x </ci>\n" + 
    "    </otherwise>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <ci> x </ci>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <otherwise> <ci> x </ci> </otherwise>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 3 )
    newChild = LibSBML::parseFormula("a + b")
    i = @@n.replaceChild(1,newChild,true)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 3 )
    child = @@n.getChild(1)
    assert( child.getType() == LibSBML::AST_PLUS )
    assert( child.getNumChildren() == 2 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

  def test_ChildFunctions_replaceInPiecewise_4
    expected = wrapMathML("  <piecewise>\n" + 
    "    <piece>\n" + 
    "      <apply>\n" + 
    "        <cos/>\n" + 
    "        <ci> x </ci>\n" + 
    "      </apply>\n" + 
    "      <apply>\n" + 
    "        <lt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn> 0 </cn>\n" + 
    "      <apply>\n" + 
    "        <eq/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "    <piece>\n" + 
    "      <cn type=\"integer\"> 3 </cn>\n" + 
    "      <apply>\n" + 
    "        <gt/>\n" + 
    "        <ci> x </ci>\n" + 
    "        <cn> 0 </cn>\n" + 
    "      </apply>\n" + 
    "    </piece>\n" + 
    "  </piecewise>\n")
    original = wrapMathML("<piecewise>" + 
    "  <piece>" + 
    "    <apply> <cos/> <ci>x</ci> </apply>" + 
    "    <apply> <lt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <cn>0</cn>" + 
    "    <apply> <eq/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "  <piece>" + 
    "    <ci>x</ci>" + 
    "    <apply> <gt/> <ci>x</ci> <cn>0</cn> </apply>" + 
    "  </piece>" + 
    "</piecewise>")
    @@n = LibSBML::readMathMLFromString(original)
    assert( @@n.getNumChildren() == 6 )
    newChild = LibSBML::parseFormula("3")
    i = @@n.replaceChild(4,newChild,true)
    assert( i == LibSBML::LIBSBML_OPERATION_SUCCESS )
    assert( @@n.getNumChildren() == 6 )
    @@s = LibSBML::writeMathMLToString(@@n)
    assert_equal true, equals(expected,@@s)
  end

end
